# 商户查询缓存

## 缓存

缓存就是数据交换的缓冲区（称作Cache），是存贮数据的临时地方，一般读写性能较高

降低后端负载，提高读写速度，降低相应时间

数据一致性成本，代码维护成本，运维成本

## 添加redis缓存

![缓存作用模型](img/%E7%BC%93%E5%AD%98%E4%BD%9C%E7%94%A8%E6%A8%A1%E5%9E%8B.png)

## 缓存更新策略

- 内存淘汰

    - 不用自己维护，利用redis的内存淘汰机制，当内存不足时自动淘汰部分数据，下次查询时更新缓存

    - 一致性差，无维护成本

- 超时剔除

    - 给缓存数据设置TTL时间，到期后自动删除缓存，下次查询时更新缓存

    - 一致性一般，维护成本低

- 主动更新

    - 修改数据库内容的同时，更新缓存

    - 一致性好，维护成本高

高一致性需求：主动更新，并以超时剔除作为兜底

### 主动更新方式

- cache aside pattern：由缓存的调用者在更新数据库的通知更新缓存（应用最多）

- read/write through pattern：缓存和数据库整合成一个服务，由服务来维护一致性。调用者直接调用该服务即可

- write behind caching pattern：调用者只操作缓存，由其他线程异步的将缓存数据库持久化到数据库，保证最终一致（缓存可能宕机，一致性和可靠性较差）

### cache aside pattern

更新数据库时删除缓存

需要保证缓存与数据库的操作的同时成功或失败

单体系统，将缓存与数据库操作放在一个事务

分布式系统，利用TCC等分布式事务方案

- 缓存操作比数据库操作速度快

    - 先删除缓存再操作数据库（x

    - 先操作数据库再删除缓存（√

## 缓存穿透

缓存穿透是指客户端请求的数据在缓存中和数据库中都不存在，这样缓存永远不会生效，这些请求都会打到数据库

缓存穿透可能造成DDOS

### 解决方案

- 缓存空对象

    - 实现简单，维护方便

    - 额外的内存消耗

    - 可能造成短期不一致

- 布隆过滤

    在客户端与redis中间加一层布隆过滤器

    存在不一定存在（但不存在一定不存在

增强id复杂度，避免被猜测id规律

做好数据基础格式校验

做好用户权限校验

做好热点参数的限流

## 缓存雪崩

缓存雪崩是指在同一时段大量的缓存key同时失效或者Redis服务宕机，导致大量请求到达数据库，带来巨大压力

- 给不同的Key的TTL添加随机值
- 利用Redis集群提高服务的可用性
- 给缓存业务添加降级限流策略
- 给业务添加多级缓存

## 缓存击穿

缓存击穿问题也叫热点Key问题，就是一个被高并发访问并且缓存重建业务较复杂的key突然失效了，无数的请求访问会在瞬间给数据库带来巨大的冲击。

解决缓存重建过程中的并发问题

一致性\<-----\>可用性:往往相互冲突

### 互斥锁

获取互斥锁失败后会等待一会儿再执行

保证一致性，无额外内存消耗，实现简单

线程需要等待，性能受影响，可能有死锁风险

```java
private boolean tryLock(String key){
    Boolean flag = stringRedisTemplate.opsForValue().setIfAbsent(key,"1",10,TimeUnit.SECONDS);
    return BooleanUtil.isTrue(flag);
}

private void unlock(String key){
    stringRedisTemplate.delete(key);
}
```
### 逻辑过期

![逻辑过期](img/%E9%80%BB%E8%BE%91%E8%BF%87%E6%9C%9F.png)

线程无需等待，性能较好

不保证一致性，有额外内存消耗

## 缓存工具类封装

可以利用泛型，代码复用
